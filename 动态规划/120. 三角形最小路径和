# -*- coding: utf-8 -*-
'''
题目：
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。
相邻的结点 在这里指的是下标与上一层结点下标相同或者等于上一层结点下标 + 1 的两个结点。

例如：
给定三角形：
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为11，（即，2 + 3 + 5 + 1 = 11）。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/triangle
'''

'''
思路：动态规划
我们用f[i][j]表示从三角形顶部走到位置(i,j)的最小路径和。
这里的位置(i,j)指的是三角形中第i行第j列（均从 0 开始编号）的位置。
由于每一步只能移动到下一行「相邻的节点」上，因此要想走到位置(i,j)，
上一步就只能在位置(i−1,j−1)或者位置(i−1,j)。
我们在这两个位置中选择一个路径和较小的来进行转移，状态转移方程为：
f[i][j]=min(f[i−1][j−1],f[i−1][j])+c[i][j]
其中c[i][j]表示位置(i,j)对应的元素值。
注意第i行有i+1个元素，它们对应的j的范围为[0,i]。当j=0或j=i时，上述状态转移方程中有一些项是没有意义的。
例如当j=0 时，f[i−1][j−1]没有意义，因此状态转移方程为：
f[i][0]=f[i−1][0]+c[i][0]
即当我们在第i行的最左侧时，我们只能从第i−1行的最左侧移动过来。
当j=i时，f[i−1][j]没有意义，因此状态转移方程为：
f[i][i]=f[i−1][i−1]+c[i][i]
即当我们在第i行的最右侧时，我们只能从第i−1行的最右侧移动过来。
最终的答案即为f[n-1][0]到f[n−1][n−1]中的最小值，其中n是三角形的行数。
'''

class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        f = [[0] * n for _ in range(n)]
        f[0][0] = triangle[0][0]

        for i in range(1, n):
            f[i][0] = f[i - 1][0] + triangle[i][0]
            for j in range(1, i):
                f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]
            f[i][i] = f[i - 1][i - 1] + triangle[i][i]
        
        return min(f[n - 1])
